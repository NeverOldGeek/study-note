Oracle
SQL Server  services.msc
	命令行启动：net start mssqlserver
	命令行停止：net stop mssqlserver
DB2
Mysql
数据库由表，关系，及操作对象组成
数据库管理系统（DBMS）-数据库-表-数据
建立数据字典，已被添加数据的表不要改变表的数据结构
表：域完整性，实体完整性，引用完整性，自定义完整性
约束方法：唯一约束，主键约束，标识列
字符前加n表示unicode
主键表示当前列不能有重复（可以有多个主键称为复合主键）
种子不会减只会自动增长,即使插入不成功种子也会自增
1.数据库是怎样存储数据的
	字段 记录 表 约束（主键（primary） 外键(foreign) 唯一键(unique) 非空(not null) check default 触发器）

2.数据库是怎样操作数据的
	insert update delete T-SQL 存储过程 函数 触发器
3.数据库是怎样显示数据的
	select

dos:通配符*（任意位置的0个或多个字符），？（1个不确定的字符）
SQL通配符：%（表示任意0个或多个字符），_（表示任意单个字符），[a-f](a到f中的任意一个字符),[a,f](a或f)，[^a-f]（不在a到f中的任意一个字符） like escape（将用escape修饰的字符后面紧接的一个字符当做普通字符）
update 字段 set 字段 = ―― where 字段 = ――

查询：
	select <列名>
	from<表明>
	[where<查询表达式>]
	[orderby<排序的列名>asc,desc(降序)]
	as(类似附值)
	in（在某某中）
	top 常量或百分比或...
	union（联合）
	group by
	between
	inter join

	1.select 字段  as 新名称 或 select 新名称 = 字段
	2.tream ,得到结果集可以在结果集上继续查询
	3.select 字段 from 表明 where 字段 is null
	4可以在显示结果集增加常量列 eg：‘安徽理工大学’as studentSchool

函数：
	1.字符串函数
	2.日期函数
	3.数学函数：SUM(),AVG(),MAX(),MIN(),COUNT(),having count()
	4.系统函数

查询（最关键理清整个查询语句执行的顺序）
	1.计算列
		eg：select sal*12 as "年薪"from emp
	2.distinct
		eg：select distinct sal from emp --- 过滤sal字段中重复的值
			当distinct后跟多个字段时，过滤的是多个字段组合的重复
	3.between
		一般用between ...and... 表示在某某区间内
	4.in【属于若干个孤立的值】
		in[a,b] 表示a，或b中的一个
	5.top
		top 3 表示前三个
	
	6.null
		null和0是不一样的，null表示没有值，0表示一个确定的值
	     	null不能参加（eg:<> != =）运算
		任何数据与null参与数学运算结果都为null;
		可以参与is null    或     is not null

		（mysql中与之对应的函数是ifnull(exr1,exr2)）函数：isnull(要判断的变量，0（定义判断正确返回的值）)
			当变量是null时返回0，否则返回变量的值
	7.order by 
		order by 表示按某个字段排序 （asc（ascend）升序 默认升序，desc（descend）降序）
			当order by 后接多个字段时，首先按第一个字段给定的排序方式（没给定默认升序）排序，
			当第一个字段值相等时，再按第二个字段排
	8.模糊查询
		SQL通配符：%（表示任意0个或多个字符），
			   _（表示任意单个字符），
			   [a-f](a到f中的任意一个字符),
			   [a,f](a或f)，
			   [^a-f]（不在a到f中的任意一个字符）
		注意：匹配的条件必须用单引号括起来，不能省略也不能改用双引号

	9.聚合函数
		函数的分类（根据函数作用后返回分）
			单行函数
				每一行返回一个值
			多行函数
				多行返回一个值
				聚合函数是多行函数
				count函数：统计有效记录的个数，值为null的数据不会被
					   当成有效的记录，重复的记录也是有效的记录
						count(*)表示返回表中所有记录的个数
	10.group by
		注：使用了group by 之后 select中只能出现分组后的整体信息，不能出现组内的详细信息

		group by a,b  先按字段a分大组，当a一样再按字段b分小组 ，select中只能出现最小分组的整体信息（select中出现的聚合函数都是对最小分组的聚合）



	11.having
	   1. 
		having字句是用来对分组之后的数据进行过滤
		因此使用having时通常都会先使用group by  
	   2.
		如果没使用group by但使用了having则意味着
		having把所有记录当做一组来进行过滤
	   3.
		having子句出现的字段必须是分组之后的组的整体信息
		having子句不允许出现组内的详细信息
	   4.
		尽管select字段中可以出现别名，但是having子句中不能出现字段别名
	   5.
		having和where的异同

		   相同点：
			都是对数据过滤，只保留有效数据
			都不允许出现字段的别名，只允许出现原始字段名
		   不同点：
			where是对原始记录过滤having是对分组后的记录过滤
			where必须写在having前面
	12.连接查询
	   定义
		将两个表或者两个以上的表以一定的条件连接起来
		从中检索出一些满足条件的数据
	   分类
		内连接
		   select * from A,B
		      （将B表中的所有记录依次与A表中的第一条连接，再与第二，...一直到最后一条  形成的是一个笛卡尔积）
		  
		   select * from 表名1 "E"
		    join 表名2 "F" on 匹配条件(当查询的字段时，要用 别名.字段名 表示，有join就必须有on。 where不能放在join前面)
		外连接
		（不仅会返回满足连接条件的记录，部分不满足连接条件的记录也会返回）
		   左外连接（不仅会返回满足连接条件的记录，而且会返回左表不满足连接条件的记录）
			定义：
				用左表中的第一行分别和右表中的所有行进行联接，如果有匹配的行则一起输出，如果右表有多行匹配
				，则结果集输出多行，如果没有匹配行，则结果集只输出一行，该输出行左边为左表第一行的内容，右
				边全部输出null，以此类推，直到左边所有行联接完毕
			left join 表名 on 匹配条件
		   右外连接（不仅会返回满足连接条件的记录，而且会返回右表不满足连接条件的记录）
			定义：
				用右表中的第一行分别和左表中的所有行进行联接，如果有匹配的行则一起输出，如果左表有多行匹配
				，则结果集输出多行，如果没有匹配行，则结果集只输出一行，该输出行左边为右表第一行的内容，右
				边全部输出null，以此类推，直到左边所有行联接完毕

			right join 表名 on 匹配条件
		   完全连接
			定义：
			    结果集中包含三部分内容：
				1.两个表中匹配的所有行记录
				2.左边中那些在右表中找不到匹配行的记录，这些记录的右边全为null
				3.右表中那些在左表中找不到匹配行的记录，这些记录的左边全为null
			full join 表名 on 匹配条件
		   交叉连接（产生的是一个笛卡尔积，等价于 select * from emp,dept）
			cross join 表名
		   自连接
			定义
			   一张表自己和自己连接起来查询数据
				练习：不准用聚合函数， 求薪水最高的员工的信息
		   联合（union）
			union：默认去掉重复的
			union all：不去掉重复的，效率较高
			定义
			   表和表之间的数据以纵向的方式连接在一起
			   注意：我们之前讲的所有连接都是以横向的方式连接在一起
  			注意
			   若干个select子句要联合成功，必须满足以下两个条件
				1.这若干个select子句输出的列数必须是相等的
				2.这若干个select子句输出的数据类型必须是兼容的

	13.视图
		create view 视图名
		as
		select * from 
			表名
			where 匹配条件

		注意问题：
			创建视图的select语句必须为所有的计算列指定别名
				--error
				create view v$_a
				    as 
					select  avg(sal) from emp;
				--ok
				create view v$_a
				    as 
					select  avg(sal) as "avg_sal" from emp;
			视图不是物理表，是虚拟表

	14.事物【重要】
		1.为什么需要事务
			事物主要用来保证数据的合理性和并发处理的能力！
			
		2.什么是事务	
			通俗的说：
				事务可以保证避免数据处于一种不合理的中间状态
				利用事务可以实现多个用户对共享资源的同时访问
			例子：
				银行中的转账操作，账户A把一定数量的款项转到账户B上，这个操
				作包括两个步骤，一个是从账户A上把存款数量减去一定数量，二是
				在账户B上把存款加上相同的数量。这两个步骤显然要么都完成，要么
				都取消，否则银行就会受损失。显然，这个转账操作中的两个步骤就
				构成一个事务。

				假设A和B用户都希望查询修改M表数据，A用户不应该M表的数据改成5，
				查询时显示的数据却是8（因为B用户修改M表的数据成8了），事务必须
				的保证多个用户对共享资源同时访问时，数据库给用户的反应是合理的		
		3.如何创建事务
			开始事务：BEGIN TRANSACTION
			提交事务：COMMIT TRANSACTION
			回滚（撤销）事务：ROLLBACK TARANSACTION
			
		  估计：begin transaction
			try{
				代码块
				commit transaction
			}catch(){
				撤销语句
			}
			一旦事务提交或回滚则事务结束。
			
		事务和线程的关系
			事务也是通过锁来解决很多问题的
			线程同步就是通过锁来解决问题的 synchronized

		事务的四大特性
			原子性：事务是一个完整的操作。
			一致性：
			隔离性：当前的事务与其他未完成的事务必须隔离
			持久性：
	15.索引

	16.存储过程

	17.游标

	18.TL_SQL
		参考E:\gangpu\file\SQLA\chapter3\理论部分\教学幻灯片\TP3V1.0.ppt